![JVM](https://github.com/AndroidCrazyBoy/AndroidStudy/blob/main/resource/images/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA.png?raw=true)



## JVM内存模型

![JVM](https://github.com/AndroidCrazyBoy/AndroidStudy/blob/main/resource/images/JVM/jvm_memory_area.png?raw=true)



### 程序计数器（Program Counter Register）

> 每个线程都有单独的PC寄存器，用于保存当前执行指令的地址，一旦指令执行，PC寄存器将更新到下一条指令。程序计数器（Program Counter Register）是一块较小的内存空间。
>
> 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

* #### 为什么要有pc register，并且是私有的

  * 当在执行多线程时候，CPU会不停的切换任务(对于多核来说是一个内核)，本质上在一个确定的时间点，只会执行某一个线程的指令。那么这时候为了能够准确的记录各个线程正在执行的当前字节码指令的地址，最后的办法就是为每一个线程一人分配一个计数器，这样一来各个线程独立计算互不干扰，虽然理论上浪费了些空间，但问题则变得简单多了。



### 虚拟机栈（JVM Stack）

* #### 栈帧(Stack Frame)

  > 在编译代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。

  * 局部变量表
    * 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法表的Code属性的max_locals数据项中确定了该方法需要分配的最大局部变量表的容量。
  * 操作数栈
    * 操作数栈也常被称为操作栈，它是一个后入先出栈。同局部变量表一样，操作数栈的最大深度也是编译的时候被写入到方法表的Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意Java数据类型，包括long和double。
  * 动态连接
    * 每个栈帧都包含一个指向运行时常量池中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。在Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。
  * 方法返回地址
  * 附加信息
    * 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。

  ​	

### 本地方法栈（Native Method Statck）



### 堆区（Heap）

> 堆区 在 JVM 所管理的内存中，堆区是最大的一块，堆区也是 Java GC 机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。 堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

> 一般的，根据 Java 虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。 如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出 OutOfMemoryError:Java heap space 异常。

* #### 栈上分配

  * 栈上分配是JVM提出的一种调优方案,**JVM通过逃逸分析确定该对象不会被外部访问,如果不会逃逸可以将该对象在栈上分配内存，每个方法或者说每个线程都有属于自己独立的栈帧,随着方法的调用结束,这样该对象所占用的内存空间就可以随栈帧出栈而销毁**，就减轻了垃圾回收的压力。

  * 对象逃逸分析：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到
    其他地方中。

  * **栈上分配的优点**:

    可以在方法调用结束后自行销毁对象,无需垃圾回收器的介入,有效减小JVM的GC压力 2.栈上分配速度很快,有效提高程序性能

    **栈上分配的缺点**:

    栈的空间是有限的,栈空间存放不了大对象,遇到大对象的创建则还是会存放在堆空间中

    

* #### 标量替换

  * 通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。 

* #### TLAB (Thread Local Allocation Buffer)

  * 在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样**每个线程都单独拥有一个空间**，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。



### 方法区（Method Area）

> 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。

>  Java 虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG 列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

* #### 运行时常量池（Runtime Constant Pool）

  * 方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如 String 类的 intern() 方法，作用是 String 维护了一个常量池，如果调用的字符 “abc” 已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。
  * 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

## 内存分配机制

以下面代码为例，来分析，Java 的实例对象在内存中的空间分配。

```java
//JVM 启动时将 Person.class 放入方法区
public class Person {

	//new Person 创建实例后，name 引用放入堆区，name 对象放入常量池
    private String name;

	//new Person 创建实例后，age = 0 放入堆区
    private int age;

	//Person 方法放入方法区，方法内代码作为 Code 属性放入方法区
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

	//toString 方法放入方法区，方法内代码作为 Code 属性放入方法区
    @Override
    public String toString() {
        return "Person{" + "name='" + name + '\'' + ", age=" + age + '}';
    }
}
```

```java
//JVM 启动时将 Test.class 放入方法区
public class Test {

	//main 方法放入方法区，方法内代码作为 Code 属性放入方法区
    public static void main(String[] args) {

        //person1 是引用放入虚拟机栈区，new 关键字开辟堆内存 Person 自定义对象放入堆区
        Person person1 = new Person("张三", 18);
        Person person2 = new Person("李四", 20);

        //通过 person 引用创建 toString() 方法栈帧
        person1.toString();
        person2.toString();
    }
}
```





### 参考文章

[Jvm内存模型深度理解]( https://cloud.tencent.com/developer/article/1406831)

[逃逸分析&标量替换](https://cloud.tencent.com/developer/article/1863058)_