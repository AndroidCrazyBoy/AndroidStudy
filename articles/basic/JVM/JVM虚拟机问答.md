### 1. JVM虚拟机

> 学习链接：https://pdai.tech/md/java/jvm/java-jvm-classload.html）

**1.1 简述JVM中类的加载机制和加载过程。**

虚拟机把描述类的数据从Class文件加载到内存中，并对数据进行校验，转换解析和初始化，最终形成可被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

​		类的加载过程分为：加载，验证，准备，解析，初始化，使用，卸载。其中验证，准备，解析三个部分成为链接。其中解析和初始化的顺序可能会不同。可能先解析后初始化，也可能先初始化后解析，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。

* 验证: 确保被加载的类的正确性

* 准备: 为类的静态变量分配内存，并将其初始化为默认值

  * 假设一个类变量的定义为: `public static int value = 3`；那么变量value在准备阶段过后的初始值为`0`，而不是`3`，因为这时候尚未开始执行任何Java方法，而把value赋值为3的`put static`指令是在程序编译后，存放于类构造器`<clinit>()`方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。
  * 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。我们可以理解为`static final`常量在编译期就将其结果放入了调用它的类的常量池中。

* 解析: 把类中的符号引用转换为直接引用

  * 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对`类`或`接口`、`字段`、`类方法`、`接口方法`、`方法类型`、`方法句柄`和`调用点`限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

    `直接引用`就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

* 初始化

  * 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。

**1.2 对象分配内存的方式：“指针碰撞”和“空闲列表”的实现方式**

指针碰撞：假设堆内存是绝对的规整的（前提），把所有使用过的内存放到一遍，把没有使用过多内存放在另一边，中间放着一个指针作为指示器，如果出现内存分配，则将分界线往空闲的那一边挪动即可。

空闲列表：如果内存不是规整而是交错的情况下使用这一种算法，如果内存不是规整的这时候虚拟机需要维护一个空闲列表记录那些空间是可用的，在对象分配的时候需要找到一块足够大的空间进行使用，然而如果没有足够大的空间，这时候就需要使用垃圾收集器进行收集之后，在根据内存的实际情况采用指针碰撞还是空闲列表。

​		 这两个对象分配的算法由堆决定是否规整决定是否使用，但是堆是否规则又和**垃圾收集器**有关，如果垃圾收集器没有使用标记整理这种算法，通常情况下使用空闲列表，而如果使用了，毫无疑问此时的内存空间是十分规整的，从而会使用指针碰撞的算法。

​		 另外，指针碰撞的效率明显是要比空闲列表的算法要高不少。

**1.3 JVM对并发分配内存处理方式**

1：对进行分配内存的动作进行同步处理-实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。

2：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程预先在JAVA堆中预先分配一小块内存，称为本地线程分配缓存（TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上进行分配。只有在TLAB用完并分配新的TLAB时，才需要加同步锁。

3：直接在栈上分配，如果对象没有发生逃逸，那么对象将不会再堆上分配。对象随线程的销毁而销毁，垃圾回收的时间少，性能高，吞吐量高，响应时间也能提高。

**1.4 类加载器， JVM类加载机制**

`启动类加载器`: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，启动类加载器是无法被Java程序直接引用的。

`扩展类加载器`: Extension ClassLoader，负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。

`应用程序类加载器`: Application ClassLoader，负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

**1.5 类的加载方式**

类加载有三种方式:

1、命令行启动应用时候由JVM初始化加载

> 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；

2、通过Class.forName()方法动态加载

> 带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。

3、通过ClassLoader.loadClass()方法动态加载

>  只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。



**1.6 Art虚拟机是基于栈还是寄存器**

ART（Android Runtime）是Android操作系统的应用程序运行环境，它在Android 4.4（KitKat）中作为Dalvik虚拟机的替代品引入，并从Android 5.0（Lollipop）开始成为默认的运行时环境。

最初，Android使用Dalvik虚拟机，这是一种基于寄存器的虚拟机，它采用.dex（Dalvik Executable）格式的字节码。Dalvik为应用程序提供了一个运行时环境，它对比JVM更适合内存、处理能力以及电量有限的移动设备。

ART虚拟机与Dalvik在架构上不同。ART采用了AOT（Ahead-Of-Time）编译，意味着应用程序在安装时就被编译成机器码，而不是像Dalvik那样在运行时通过JIT（Just-In-Time）编译成机器码。这种方法减少了运行时的CPU负载，提高了性能和响应速度，同时也增加了安装时的处理量和应用的存储占用。

在虚拟机设计的上下文中，基于栈的和基于寄存器的虚拟机主要区别在于它们的指令集和执行模型。基于栈的虚拟机（如JVM）使用操作数栈进行指令的执行，而基于寄存器的虚拟机（如Dalvik）则使用一组寄存器来存储指令的间接结果。

由于ART使用静态编译生成设备上的本地指令，这使得它在设计上与传统意义上的基于寄存器或基于栈的虚拟机有所不同。ART不关注字节码执行模型，因为它不在运行时执行字节码。相反，它将字节码翻译成了机器码，机器码可以直接运行在处理器上，无论它是基于栈还是寄存器。处理器架构本身将决定机器码是基于栈的还是基于寄存器的。

总的来说，ART不可以简单划分为传统意义上的基于栈或基于寄存器的虚拟机，而是最好描述为一个采用AOT编译策略的运行时环境。



